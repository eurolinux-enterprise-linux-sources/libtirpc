diff --git a/.gitignore b/.gitignore
index f4a325a..a5a8f11 100644
--- a/.gitignore
+++ b/.gitignore
@@ -13,6 +13,7 @@ ltmain.sh
 Makefile.in
 missing
 config.h.in
+m4/*
 # files generated by configure
 confdefs.h
 config.status
diff --git a/COPYING b/COPYING
index 8b548d6..8e99af8 100644
--- a/COPYING
+++ b/COPYING
@@ -1,338 +1,4 @@
-Sun Industry Standards Source License 1.0
-
-DEFINITIONS
-
-1.1.  "Commercial Use" means distribution or otherwise
-making the Original Code available to a third party.
-
-1.2.  "Contributor Version" means the combination of the
-Original Code, and the Modifications made by that particular
-Contributor.
-
-1.3.  "Electronic Distribution Mechanism" means a mechanism
-generally accepted in the software development community for
-the electronic transfer of data.
-
-1.4.  "Executable" means Original Code in any form other
-than Source Code.
-
-1.5.  "Initial Developer" means the individual or entity
-identified as the Initial Developer in the Source Code
-notice required by 2 (Exhibit A)
-
-1.6.  "Larger Work" means a work which combines Original
-Code or portions thereof with code not governed by the terms
-of this License.
-
-1.7.  "License" means this document.
-
-1.8.  "Licensable" means having the right to grant, to the
-maximum extent possible, whether at the time of the initial
-grant or subsequently acquired, any and all of the rights
-conveyed herein.
-
-1.9.  "Modifications" means any addition to or deletion from
-the substance or structure of either the Original Code or
-any previous Modifications.  A Modification is:
-
-A.  Any addition to or deletion from the contents of a file
-containing Original Code or previous Modifications.
-
-B.  Any new file that contains any part of the Original Code
-or previous Modifications.  .
-
-1.10.  "Original Code" means Source Code of computer
-software code which is described in the Source Code notice
-required by Exhibit A as Original Code.
-
-1.11.  "Patent Claims" means any patent claims, now owned or
-hereafter acquired, including without limitation, method,
-process, and apparatus claims, in any patent Licensable by
-grantor.
-
-1.12.  "Source Code" means the preferred form of the
-Original Code for making modifications to it, including all
-modules it contains, plus any associated interface
-definition files, or scripts used to control compilation and
-installation of an Executable.
-
-1.13.  "Standards" means the standard identified in Exhibit
-B or a subsequent version of such standard.
-
-1.14.  "You" or "Your" means an individual or a legal entity
-exercising rights under, and complying with all of the terms
-of, this License or a future version of this License issued
-under Section 6.1.  For legal entities, "You" includes any
-entity which controls, is controlled by, or is under common
-control with You.  For purposes of this definition,
-"control" means (a) the power, direct or indirect, to cause
-the direction or management of such entity, whether by
-contract or otherwise, or (b) ownership of more than fifty
-percent (50%) of the outstanding shares or beneficial
-ownership of such entity.
-
-2.0 SOURCE CODE LICENSE
-
-2.1 The Initial Developer Grant:  The Initial Developer
-hereby grants You a world-wide, royalty-free, non-exclusive
-license, subject to third party intellectual property
-claims:
-
-a) under intellectual property rights (other than patent or
-trademark) Licensable by Initial Developer to use,
-reproduce, modify, display, perform, sub license and
-distribute the Original Code (or portions thereof )with or
-without Modifications, and/or as part of a Larger Work; and
-
-b) under Patents Claims infringed by the making, using or
-selling of Original Code, to make, have made, use, practice,
-sell, and offer for sale, and/or otherwise dispose of the
-Original Code (or portions thereof).
-
-c) the licenses granted in this Section 2.1(a ) and (b) are
-effective on the date Initial Developer first distributes
-Original Code under the terms of this License.
-
-d) Notwithstanding Section 2.1(b )above, no patent license
-is granted:  1) for code that You delete from the Original
-Code; 2) separate from the Original Code; or 3) for
-infringements caused by:  i) the modification of the
-Original Code or
-
-ii) the combination of the Original Code with other software
-or devices, including but not limited to Modifications.
-
-3.0 DISTRIBUTION OBLIGATIONS
-
-3.1 Application of License.  The Source Code version of
-Original Code may be distributed only under the terms of
-this License or a future version of this License released
-under Section 6.1, and You must include a copy of this
-License with every copy of the Source Code You distribute.
-You may not offer or impose any terms on any Source Code
-version that alters or restricts the applicable version of
-this License or the recipient's rights hereunder.  Your
-license for shipment of the Contributor Version is
-conditioned upon your full compliance with this Section.
-The Modifications which you create must comply with all
-requirements set out by the Standards body in effect 120
-days before You ship the Contributor Version.  In the event
-that the Modifications do not meet such requirements, You
-agree to publish (i) any deviation from the Standards
-protocol resulting from implementation of your Modifications
-and (ii) a reference implementation of Your Modifications,
-and to make any such deviation and reference implementation
-available to all third parties under the same terms as the
-license on a royalty free basis within thirty (30) days of
-Your first customer shipment of Your Modifications.
-
-3.2 Required Notices.  You must duplicate the notice in
-Exhibit A in each file of the Source Code.  If it is not
-possible to put such notice in a particular Source Code file
-due to its structure, then You must include such notice in a
-location (such as a relevant directory ) where a user would
-be likely to look for such a notice.  If You created one or
-more Modifications ) You may add your name as a Contributor
-to the notice described in Exhibit A.  You must also
-duplicate this License in any documentation for the Source
-Code where You describe recipients' rights or ownership
-rights relating to Initial Code.  You may choose to offer,
-and to charge a fee for, warranty, support, indemnity or
-liability obligations to one or more recipients of Your
-version of the Code.  However, You may do so only
-
-on Your own behalf, and not on behalf of the Initial
-Developer.  You must make it absolutely clear than any such
-warranty, support, indemnity or liability obligation is
-offered by You alone, and You hereby agree to indemnify the
-Initial Developer for any liability incurred by the Initial
-Developer as a result of warranty, support, indemnity or
-liability terms You offer.
-
-3.3 Distribution of Executable Versions.  You may distribute
-Original Code in Executable and Source form only if the
-requirements of Section 3.1 and 3.2 have been met for that
-Original Code, and if You include a notice stating that the
-Source Code version of the Original Code is available under
-the terms of this License.  The notice must be conspicuously
-included in any notice in an Executable or Source versions,
-related documentation or collateral in which You describe
-recipients' rights relating to the Original Code.  You may
-distribute the Executable and Source versions of Your
-version of the Code or ownership rights under a license of
-Your choice, which may contain terms different from this
-License, provided that You are in compliance with the terms
-of this License.  If You distribute the Executable and
-Source versions under a different license You must make it
-absolutely clear that any terms which differ from this
-License are offered by You alone, not by the Initial
-Developer .  You hereby agree to indemnify the Initial
-Developer for any liability incurred by the Initial
-Developer as a result of any such terms You offer .
-
-3.4 Larger Works.  You may create a Larger Work by combining
-Original Code with other code not governed by the terms of
-this License and distribute the Larger Work as a single
-product.  In such a case, You must make sure the
-requirements of this License are fulfilled for the Original
-Code.
-
-4.0 INABILITY TO COMPLY DUE TO STATUTE OR REGULATION
-
-If it is impossible for You to comply with any of the terms
-of this License with respect to some or all of the Original
-Code due to statute, judicial order, or regulation then You
-must:
-
-a) comply with the terms of this License to the maximum
-extent possible; and
-
-b) describe the limitations and the code they affect.  Such
-description must be included in the LEGAL file described in
-Section 3.2 and must be included with all distributions of
-the Source Code.  Except to the extent prohibited by statute
-or regulation, such description must be sufficiently
-detailed for a recipient of ordinary skill to be able to
-understand it.
-
-5.0 APPLICATION OF THIS LICENSE This License applies to code
-to which the Initial Developer has attached the notice in
-Exhibit A and to related Modifications as set out in Section
-3.1.
-
-6.0 VERSIONS OF THE LICENSE
-
-6.1 New Versions.  Sun Microsystems, Inc.  Sun may publish
-revised and/or new versions of the License from time to
-time.  Each version will be given a distinguishing version
-number .
-
-6.2 Effect of New Versions.  Once Original Code has been
-published under a particular version of the License, You may
-always continue to use it under the terms of that version.
-You may also choose to use such Original Code under the
-terms of any subsequent version of the License published by
-Sun.  No one other than Sun has the right to modify the
-terms applicable to Original Code.
-
-7.  DISCLAIMER OF W ARRANTY.  ORIGINAL CODE IS PROVIDED
-UNDER THIS LICENSE ON AN "AS IS" BASIS, WITHOUT WARRANTY OF
-ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, WITHOUT
-LIMITATION, WARRANTIES THAT THE ORIGINAL CODE IS FREE OF
-DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR
-NON-INFRINGING.  THE ENTIRE RISK AS TO THE QUALITY AND
-PERFORMANCE OF THE ORIGINAL CODE IS WITH YOU.  SHOULD ANY
-ORIGINAL CODE PROVE DEFECTIVE IN ANY RESPECT, YOU (NOT THE
-INITIAL DEVELOPER )ASSUME THE COST OF ANY NECESSARY
-SERVICING, REPAIR OR CORRECTION.  THIS DISCLAIMER OF
-WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS LICENSE.  NO
-USE OF ANY ORIGINAL CODE IS AUTHORIZED HEREUNDER EXCEPT
-UNDER THIS DISCLAIMER.
-
-8.0 TERMINATION
-
-8.1 This License and the rights granted hereunder will
-terminate automatically if You fail to comply with terms
-herein and fail to cure such breach within 30 days of
-becoming aware of the breach.  All sublicenses to the
-Original Code which are properly granted shall survive any
-termination of this License.  Provisions which, by their
-nature, must remain in effect beyond the termination of this
-License shall survive.
-
-8.2 .In the event of termination under Section 8.1 above,
-all end user license agreements (excluding distributors and
-resellers) which have been validly granted by You or any
-distributor hereunder prior to termination shall survive
-termination.
-
-9.0 LIMIT OF LIABILITY UNDER NO CIRCUMSTANCES AND UNDER NO
-LEGAL THEORY, WHETHER TORT (INCLUDING NEGLIGENCE) ,CONTRACT,
-OR OTHER WISE, SHALL YOU, THE INITIAL DEVELOPER, ANY OTHER
-CONTRIBUTOR, OR ANY DISTRIBUTOR OF ORIGINAL CODE, OR ANY
-SUPPLIER OF ANY OF SUCH PARTIES, BE LIABLE TO ANY PERSON FOR
-ANY INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
-OF ANY CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR
-LOSS OF GOOD WILL, WORK STOPPAGE, COMPUTER FAILURE OR
-MALFUNCTION, OR ANY AND ALL OTHER COMMERCIAL DAMAGES OR
-LOSSES, EVEN IF SUCH PARTY SHALL HAVE BEEN INFORMED OF THE
-POSSIBILITY OF SUCH DAMAGES.  THIS LIMITATION OF LIABILITY
-SHALL NOT APPLY TO LIABILITY FOR DEATH OR PERSONAL INJURY
-RESULTING FROM SUCH PARTYS NEGLIGENCE TO THE EXTENT
-APPLICABLE LAW PROHIBITS SUCH LIMITATION.  SOME
-JURISDICTIONS DO NOT ALLOW THE EXCLUSION OR LIMITATION OF
-INCIDENTAL OR CONSEQUENTIAL DAMAGES, SO THIS EXCLUSION AND
-LIMITATION MAY NOT APPLY TO YOU.
-
-10.0 U .S.  GOVERNMENT END USERS U.S.  Government:  If this
-Software is being acquired by or on behalf of the U.S.
-Government or by a U.S.  Government prime contractor or
-subcontractor (at any tier), then the Government's rights in
-the Software and accompanying documentation shall be only as
-set forth in this license; this is in accordance with 48 C.F
-.R.  227.7201 through 227.7202-4 (for Department of Defense
-(DoD) acquisitions )and with 48 C.F.R.2.101 and 12.212( for
-non-DoD acquisitions).
-
-11.0 MISCELLANEOUS This License represents the complete
-agreement concerning subject matter hereof.  If any
-provision of this License is held to be unenforceable, such
-provision shall be reformed only to the extent necessary to
-make it enforceable.  This License shall be governed by
-California law provisions (except to the extent applicable
-law, if any, provides otherwise), excluding its
-conflict-of-law provisions.  With respect to disputes in
-which at least one party is a citizen of, or an entity
-chartered or registered to do business in the United States
-of America, any litigation relating to this License shall be
-subject to the jurisdiction of the Federal Courts of the
-Northern District of California, with venue lying in Santa
-Clara County, California, with the losing party responsible
-for costs, including without limitation, court costs and
-reasonable attorneys fees and expenses.  The application of
-the United Nations Convention on Contracts for the
-International Sale of Goods is expressly excluded.  Any law
-or regulation which provides that the language of a contract
-shall be construed against the drafter shall not apply to
-this License.
-
-EXHIBIT A - Sun Standards
-
-"The contents of this file are subject to the Sun Standards
-License Version 1.0 the (the "License";) You may not use
-this file except in compliance with the License.  You may
-obtain a copy of the License at
-_______________________________.
-
-    Software distributed under the License is distributed on
-an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either
-express or implied.  See the License for the specific
-language governing rights and limitations under the License.
-
-The Original Code is Copyright 1998 by Sun Microsystems, Inc
-
-The Initial Developer of the Original Code is:  Sun
-Microsystems, Inc.
-
-Portions created by _____________________________ are
-Copyright ______________________________.
-
-All Rights Reserved.
-
-Contributors:  ______________________________________.
-
-EXHIBIT B - Sun Standards
-
-The Standard is defined as the following IETF RFCs:
-
-RFC1831:  RPC:  Remote Procedure Call Protocol Specification
-Version 2 RFC1832:  XDR:  External Data REpresentation
-Standard RFC1833:  Binding Protocols for ONC RPC Version 2
-RFC2078:  Generic Security Service Application Program
-Interface, Version 2 RFC2203:  RPCSEC_GSS Protocol
-Specification RFC2695:  Authentication Mechanisms for ONC RPC
-
-*
+/*
  * Copyright (c) Copyright (c) Bull S.A.  2005  All Rights Reserved.
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
diff --git a/Makefile.am b/Makefile.am
index 7f5f37b..1a7596b 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,4 +1,5 @@
 SUBDIRS = src man doc
+ACLOCAL_AMFLAGS = -I m4
 
 nobase_include_HEADERS = tirpc/netconfig.h \
 			 tirpc/rpcsvc/crypt.x \
diff --git a/configure.ac b/configure.ac
index 0f3ce42..97c6f2c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -18,7 +19,6 @@ fi
 AC_PROG_CC
 AM_CONFIG_HEADER(config.h)
 AC_PROG_LIBTOOL
-##AC_PROG_RANLIB
 AC_HEADER_DIRENT
 AC_PREFIX_DEFAULT(/usr)
 AC_CHECK_HEADERS([arpa/inet.h fcntl.h libintl.h limits.h locale.h netdb.h netinet/in.h stddef.h stdint.h stdlib.h string.h sys/ioctl.h sys/param.h sys/socket.h sys/time.h syslog.h unistd.h])
diff --git a/src/Makefile.am b/src/Makefile.am
index 7b002da..6731ff9 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -67,29 +67,3 @@ endif
 ## libtirpc_a_SOURCES += netname.c netnamer.c rpcdname.c \
 ## libtirpc_a_SOURCES += rtime.c \
 ## auth_time.c auth_des.c authdes_prot.c 
-
-if GSS
-$(libtirpc_la_OBJECTS) :auth_none.c auth_unix.c authunix_prot.c bindresvport.c clnt_bcast.c \
-        clnt_dg.c clnt_generic.c clnt_perror.c clnt_raw.c clnt_simple.c \
-        clnt_vc.c rpc_dtablesize.c getnetconfig.c getnetpath.c getrpcent.c \
-        getrpcport.c mt_misc.c pmap_clnt.c pmap_getmaps.c pmap_getport.c \
-        pmap_prot.c pmap_prot2.c pmap_rmt.c rpc_prot.c rpc_commondata.c \
-        rpc_callmsg.c rpc_generic.c rpc_soc.c rpcb_clnt.c rpcb_prot.c \
-        rpcb_st_xdr.c svc.c svc_auth.c svc_dg.c svc_auth_unix.c svc_generic.c \
-        svc_raw.c svc_run.c svc_simple.c svc_vc.c \
-	xdr.c xdr_rec.c xdr_array.c xdr_float.c xdr_mem.c xdr_reference.c xdr_stdio.c \
-	auth_gss.c authgss_prot.c svc_auth_gss.c getpeereid.c \
-	auth_time.c auth_des.c authdes_prot.c svc_auth_none.c
-        
-else
-$(libtirpc_la_OBJECTS) :auth_none.c auth_unix.c authunix_prot.c bindresvport.c clnt_bcast.c \
-        clnt_dg.c clnt_generic.c clnt_perror.c clnt_raw.c clnt_simple.c \
-        clnt_vc.c rpc_dtablesize.c getnetconfig.c getnetpath.c getrpcent.c \
-        getrpcport.c mt_misc.c pmap_clnt.c pmap_getmaps.c pmap_getport.c \
-        pmap_prot.c pmap_prot2.c pmap_rmt.c rpc_prot.c rpc_commondata.c \
-        rpc_callmsg.c rpc_generic.c rpc_soc.c rpcb_clnt.c rpcb_prot.c \
-        rpcb_st_xdr.c svc.c svc_auth.c svc_dg.c svc_auth_unix.c svc_generic.c \
-        svc_raw.c svc_run.c svc_simple.c svc_vc.c \
-	xdr.c xdr_rec.c xdr_array.c xdr_float.c xdr_mem.c xdr_reference.c xdr_stdio.c \
-	getpeereid.c auth_time.c auth_des.c authdes_prot.c
-endif
diff --git a/src/auth_des.c b/src/auth_des.c
index 37e7667..f0c8b8c 100644
--- a/src/auth_des.c
+++ b/src/auth_des.c
@@ -223,6 +223,7 @@ authdes_pk_seccreate(const char *servername, netobj *pkey, u_int window,
 		goto failed;
 	}
 	ad->ad_nis_srvr = NULL; /* not needed any longer */
+	auth_get(auth);		/* Reference for caller */
 	return (auth);
 
 failed:
@@ -472,6 +473,12 @@ authdes_destroy(AUTH *auth)
 	FREE(auth, sizeof(AUTH));
 }
 
+static bool_t
+authdes_wrap(AUTH *auth, XDR *xdrs, xdrproc_t xfunc, caddr_t xwhere)
+{
+	return ((*xfunc)(xdrs, xwhere));
+}
+
 static struct auth_ops *
 authdes_ops(void)
 {
@@ -487,6 +494,8 @@ authdes_ops(void)
 		ops.ah_validate = authdes_validate;
 		ops.ah_refresh = authdes_refresh;
 		ops.ah_destroy = authdes_destroy;
+		ops.ah_wrap = authdes_wrap;
+		ops.ah_unwrap = authdes_wrap;
         }
 	mutex_unlock(&authdes_ops_lock);
 	return (&ops);
diff --git a/src/auth_gss.c b/src/auth_gss.c
index df3017a..a992049 100644
--- a/src/auth_gss.c
+++ b/src/auth_gss.c
@@ -200,6 +200,8 @@ authgss_create(CLIENT *clnt, gss_name_t name, struct rpc_gss_sec *sec)
 
 	if (!authgss_refresh(auth))
 		auth = NULL;
+	else
+		auth_get(auth); /* Reference for caller */
 
 	clnt->cl_auth = save_auth;
 
@@ -555,9 +557,20 @@ authgss_destroy_context(AUTH *auth)
 
 	if (gd->gc.gc_ctx.length != 0) {
 		if (gd->established) {
+			AUTH *save_auth = NULL;
+
+			/* Make sure we use the right auth_ops */
+			if (gd->clnt->cl_auth != auth) {
+				save_auth = gd->clnt->cl_auth;
+				gd->clnt->cl_auth = auth;
+			}
+
 			gd->gc.gc_proc = RPCSEC_GSS_DESTROY;
 			clnt_call(gd->clnt, NULLPROC, (xdrproc_t)xdr_void, NULL,
 				  (xdrproc_t)xdr_void, NULL, AUTH_TIMEOUT);
+			
+			if (save_auth != NULL)
+				gd->clnt->cl_auth = save_auth;
 		}
 		gss_release_buffer(&min_stat, &gd->gc.gc_ctx);
 		/* XXX ANDROS check size of context  - should be 8 */
diff --git a/src/auth_none.c b/src/auth_none.c
index a439ec6..008c589 100644
--- a/src/auth_none.c
+++ b/src/auth_none.c
@@ -155,6 +155,12 @@ authnone_destroy(AUTH *client)
 {
 }
 
+static bool_t
+authnone_wrap(AUTH *auth, XDR *xdrs, xdrproc_t xfunc, caddr_t xwhere)
+{
+	return ((*xfunc)(xdrs, xwhere));
+}
+
 static struct auth_ops *
 authnone_ops()
 {
@@ -170,6 +176,8 @@ authnone_ops()
 		ops.ah_validate = authnone_validate;
 		ops.ah_refresh = authnone_refresh;
 		ops.ah_destroy = authnone_destroy;
+		ops.ah_wrap = authnone_wrap;
+		ops.ah_unwrap = authnone_wrap;
 	}
 	mutex_unlock(&ops_lock);
 	return (&ops);
diff --git a/src/auth_unix.c b/src/auth_unix.c
index 71ca15d..4b9b13f 100644
--- a/src/auth_unix.c
+++ b/src/auth_unix.c
@@ -49,7 +49,9 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include <string.h>
+#include <errno.h>
 
+#include <rpc/clnt.h>
 #include <rpc/types.h>
 #include <rpc/xdr.h>
 #include <rpc/auth.h>
@@ -95,6 +97,8 @@ authunix_create(machname, uid, gid, len, aup_gids)
 	AUTH *auth;
 	struct audata *au;
 
+	memset(&rpc_createerr, 0, sizeof(rpc_createerr));
+
 	/*
 	 * Allocate and set up auth handle
 	 */
@@ -102,14 +106,16 @@ authunix_create(machname, uid, gid, len, aup_gids)
 	auth = mem_alloc(sizeof(*auth));
 #ifndef _KERNEL
 	if (auth == NULL) {
-		warnx("authunix_create: out of memory");
+		rpc_createerr.cf_stat = RPC_SYSTEMERROR;
+		rpc_createerr.cf_error.re_errno = ENOMEM;
 		goto cleanup_authunix_create;
 	}
 #endif
 	au = mem_alloc(sizeof(*au));
 #ifndef _KERNEL
 	if (au == NULL) {
-		warnx("authunix_create: out of memory");
+		rpc_createerr.cf_stat = RPC_SYSTEMERROR;
+		rpc_createerr.cf_error.re_errno = ENOMEM;
 		goto cleanup_authunix_create;
 	}
 #endif
@@ -134,15 +140,18 @@ authunix_create(machname, uid, gid, len, aup_gids)
 	 * Serialize the parameters into origcred
 	 */
 	xdrmem_create(&xdrs, mymem, MAX_AUTH_BYTES, XDR_ENCODE);
-	if (! xdr_authunix_parms(&xdrs, &aup)) 
-		abort();
+	if (!xdr_authunix_parms(&xdrs, &aup)) {
+		rpc_createerr.cf_stat = RPC_CANTENCODEARGS;
+		goto cleanup_authunix_create;
+	}
 	au->au_origcred.oa_length = len = XDR_GETPOS(&xdrs);
 	au->au_origcred.oa_flavor = AUTH_UNIX;
 #ifdef _KERNEL
 	au->au_origcred.oa_base = mem_alloc((u_int) len);
 #else
 	if ((au->au_origcred.oa_base = mem_alloc((u_int) len)) == NULL) {
-		warnx("authunix_create: out of memory");
+		rpc_createerr.cf_stat = RPC_SYSTEMERROR;
+		rpc_createerr.cf_error.re_errno = ENOMEM;
 		goto cleanup_authunix_create;
 	}
 #endif
@@ -153,6 +162,7 @@ authunix_create(machname, uid, gid, len, aup_gids)
 	 */
 	auth->ah_cred = au->au_origcred;
 	marshal_new_auth(auth);
+	auth_get(auth);		/* Reference for caller */
 	return (auth);
 #ifndef _KERNEL
  cleanup_authunix_create:
@@ -177,18 +187,64 @@ authunix_create_default()
 	int len;
 	char machname[MAXHOSTNAMELEN + 1];
 	uid_t uid;
-	gid_t gid;
-	gid_t gids[NGRPS];
+	gid_t gid, *gids;
+	AUTH *result;
+
+	memset(&rpc_createerr, 0, sizeof(rpc_createerr));
 
-	if (gethostname(machname, sizeof machname) == -1)
-		abort();
+	if (gethostname(machname, sizeof machname) == -1) {
+		rpc_createerr.cf_error.re_errno = errno;
+		goto out_err;
+	}
 	machname[sizeof(machname) - 1] = 0;
 	uid = geteuid();
 	gid = getegid();
-	if ((len = getgroups(NGRPS, gids)) < 0)
-		abort();
+
+	/* According to glibc comments, an intervening setgroups(2)
+	 * call can increase the number of supplemental groups between
+	 * these two getgroups(2) calls. */
+retry:
+	len = getgroups(0, NULL);
+	if (len == -1) {
+		rpc_createerr.cf_error.re_errno = errno;
+		goto out_err;
+	}
+
+	/* Bump allocation size.  A zero allocation size may result in a
+	 * NULL calloc(3) result, which is not reliably distinguishable
+	 * from a memory allocation error. */
+	gids = calloc(len + 1, sizeof(gid_t));
+	if (gids == NULL) {
+		rpc_createerr.cf_error.re_errno = ENOMEM;
+		goto out_err;
+	}
+
+	len = getgroups(len, gids);
+	if (len == -1) {
+		rpc_createerr.cf_error.re_errno = errno;
+		free(gids);
+		if (rpc_createerr.cf_error.re_errno == EINVAL) {
+			rpc_createerr.cf_error.re_errno = 0;
+			goto retry;
+		}
+		goto out_err;
+	}
+
+	/*
+	 * AUTH_UNIX sends on the wire only the first NGRPS groups in the
+	 * supplemental groups list.
+	 */
+	if (len > NGRPS)
+		len = NGRPS;
+
 	/* XXX: interface problem; those should all have been unsigned */
-	return (authunix_create(machname, uid, gid, len, gids));
+	result = authunix_create(machname, uid, gid, len, gids);
+	free(gids);
+	return result;
+
+out_err:
+	rpc_createerr.cf_stat = RPC_SYSTEMERROR;
+	return NULL;
 }
 
 /*
@@ -341,6 +397,12 @@ marshal_new_auth(auth)
 	XDR_DESTROY(xdrs);
 }
 
+static bool_t
+authunix_wrap(AUTH *auth, XDR *xdrs, xdrproc_t xfunc, caddr_t xwhere)
+{
+	return ((*xfunc)(xdrs, xwhere));
+}
+
 static struct auth_ops *
 authunix_ops()
 {
@@ -356,6 +418,8 @@ authunix_ops()
 		ops.ah_validate = authunix_validate;
 		ops.ah_refresh = authunix_refresh;
 		ops.ah_destroy = authunix_destroy;
+		ops.ah_wrap = authunix_wrap;
+		ops.ah_unwrap = authunix_wrap;
 	}
 	mutex_unlock(&ops_lock);
 	return (&ops);
diff --git a/src/authgss_prot.c b/src/authgss_prot.c
index ab72d91..0168318 100644
--- a/src/authgss_prot.c
+++ b/src/authgss_prot.c
@@ -44,6 +44,34 @@
 #include <rpc/rpc.h>
 #include <gssapi/gssapi.h>
 
+/* additional space needed for encoding */
+#define RPC_SLACK_SPACE 1024
+
+bool_t
+xdr_rpc_gss_buf(XDR *xdrs, gss_buffer_t buf, u_int maxsize)
+{
+	bool_t xdr_stat;
+	u_int tmplen;
+
+	if (xdrs->x_op != XDR_DECODE) {
+		if (buf->length > UINT_MAX)
+			return FALSE;
+		else
+			tmplen = buf->length;
+	}
+	xdr_stat = xdr_bytes(xdrs, (char **)&buf->value, &tmplen, maxsize);
+
+	if (xdr_stat && xdrs->x_op == XDR_DECODE)
+		buf->length = tmplen;
+
+	log_debug("xdr_rpc_gss_buf: %s %s (%p:%d)",
+		  (xdrs->x_op == XDR_ENCODE) ? "encode" : "decode",
+		  (xdr_stat == TRUE) ? "success" : "failure",
+		  buf->value, buf->length);
+
+	return xdr_stat;
+}
+
 bool_t
 xdr_rpc_gss_cred(XDR *xdrs, struct rpc_gss_cred *p)
 {
@@ -53,8 +81,7 @@ xdr_rpc_gss_cred(XDR *xdrs, struct rpc_gss_cred *p)
 		    xdr_enum(xdrs, (enum_t *)&p->gc_proc) &&
 		    xdr_u_int(xdrs, &p->gc_seq) &&
 		    xdr_enum(xdrs, (enum_t *)&p->gc_svc) &&
-		    xdr_bytes(xdrs, (char **)&p->gc_ctx.value,
-			      (u_int *)&p->gc_ctx.length, MAX_AUTH_BYTES));
+		    xdr_rpc_gss_buf(xdrs, &p->gc_ctx, MAX_AUTH_BYTES));
 
 	log_debug("xdr_rpc_gss_cred: %s %s "
 		  "(v %d, proc %d, seq %d, svc %d, ctx %p:%d)",
@@ -70,9 +97,9 @@ bool_t
 xdr_rpc_gss_init_args(XDR *xdrs, gss_buffer_desc *p)
 {
 	bool_t xdr_stat;
+	u_int maxlen = (u_int)(p->length + RPC_SLACK_SPACE);
 
-	xdr_stat = xdr_bytes(xdrs, (char **)&p->value,
-			      (u_int *)&p->length, MAX_NETOBJ_SZ);
+	xdr_stat = xdr_rpc_gss_buf(xdrs, p, maxlen);
 
 	log_debug("xdr_rpc_gss_init_args: %s %s (token %p:%d)",
 		  (xdrs->x_op == XDR_ENCODE) ? "encode" : "decode",
@@ -87,13 +114,14 @@ xdr_rpc_gss_init_res(XDR *xdrs, struct rpc_gss_init_res *p)
 {
 	bool_t xdr_stat;
 
-	xdr_stat = (xdr_bytes(xdrs, (char **)&p->gr_ctx.value,
-			      (u_int *)&p->gr_ctx.length, MAX_NETOBJ_SZ) &&
+	u_int ctx_maxlen = (u_int)(p->gr_ctx.length + RPC_SLACK_SPACE);
+	u_int tok_maxlen = (u_int)(p->gr_token.length + RPC_SLACK_SPACE);
+
+	xdr_stat = (xdr_rpc_gss_buf(xdrs, &p->gr_ctx, ctx_maxlen) &&
 		    xdr_u_int(xdrs, &p->gr_major) &&
 		    xdr_u_int(xdrs, &p->gr_minor) &&
 		    xdr_u_int(xdrs, &p->gr_win) &&
-		    xdr_bytes(xdrs, (char **)&p->gr_token.value,
-			      (u_int *)&p->gr_token.length, MAX_NETOBJ_SZ));
+		    xdr_rpc_gss_buf(xdrs, &p->gr_token, tok_maxlen));
 
 	log_debug("xdr_rpc_gss_init_res %s %s "
 		  "(ctx %p:%d, maj %d, min %d, win %d, token %p:%d)",
@@ -115,27 +143,32 @@ xdr_rpc_gss_wrap_data(XDR *xdrs, xdrproc_t xdr_func, caddr_t xdr_ptr,
 	OM_uint32	maj_stat, min_stat;
 	int		start, end, conf_state;
 	bool_t		xdr_stat;
+	u_int		databuflen, maxwrapsz;
 
 	/* Skip databody length. */
 	start = XDR_GETPOS(xdrs);
 	XDR_SETPOS(xdrs, start + 4);
 
+	memset(&databuf, 0, sizeof(databuf));
+	memset(&wrapbuf, 0, sizeof(wrapbuf));
+
 	/* Marshal rpc_gss_data_t (sequence number + arguments). */
 	if (!xdr_u_int(xdrs, &seq) || !(*xdr_func)(xdrs, xdr_ptr))
 		return (FALSE);
 	end = XDR_GETPOS(xdrs);
 
 	/* Set databuf to marshalled rpc_gss_data_t. */
-	databuf.length = end - start - 4;
+	databuflen = end - start - 4;
 	XDR_SETPOS(xdrs, start + 4);
-	databuf.value = XDR_INLINE(xdrs, databuf.length);
+	databuf.value = XDR_INLINE(xdrs, databuflen);
+	databuf.length = databuflen;
 
 	xdr_stat = FALSE;
 
 	if (svc == RPCSEC_GSS_SVC_INTEGRITY) {
 		/* Marshal databody_integ length. */
 		XDR_SETPOS(xdrs, start);
-		if (!xdr_u_int(xdrs, (u_int *)&databuf.length))
+		if (!xdr_u_int(xdrs, (u_int *)&databuflen))
 			return (FALSE);
 
 		/* Checksum rpc_gss_data_t. */
@@ -147,8 +180,8 @@ xdr_rpc_gss_wrap_data(XDR *xdrs, xdrproc_t xdr_func, caddr_t xdr_ptr,
 		}
 		/* Marshal checksum. */
 		XDR_SETPOS(xdrs, end);
-		xdr_stat = xdr_bytes(xdrs, (char **)&wrapbuf.value,
-				     (u_int *)&wrapbuf.length, MAX_NETOBJ_SZ);
+		maxwrapsz = (u_int)(wrapbuf.length + RPC_SLACK_SPACE);
+		xdr_stat = xdr_rpc_gss_buf(xdrs, &wrapbuf, maxwrapsz);
 		gss_release_buffer(&min_stat, &wrapbuf);
 	}
 	else if (svc == RPCSEC_GSS_SVC_PRIVACY) {
@@ -161,8 +194,8 @@ xdr_rpc_gss_wrap_data(XDR *xdrs, xdrproc_t xdr_func, caddr_t xdr_ptr,
 		}
 		/* Marshal databody_priv. */
 		XDR_SETPOS(xdrs, start);
-		xdr_stat = xdr_bytes(xdrs, (char **)&wrapbuf.value,
-				     (u_int *)&wrapbuf.length, MAX_NETOBJ_SZ);
+		maxwrapsz = (u_int)(wrapbuf.length + RPC_SLACK_SPACE);
+		xdr_stat = xdr_rpc_gss_buf(xdrs, &wrapbuf, maxwrapsz);
 		gss_release_buffer(&min_stat, &wrapbuf);
 	}
 	return (xdr_stat);
@@ -188,14 +221,12 @@ xdr_rpc_gss_unwrap_data(XDR *xdrs, xdrproc_t xdr_func, caddr_t xdr_ptr,
 
 	if (svc == RPCSEC_GSS_SVC_INTEGRITY) {
 		/* Decode databody_integ. */
-		if (!xdr_bytes(xdrs, (char **)&databuf.value, (u_int *)&databuf.length,
-			       MAX_NETOBJ_SZ)) {
+		if (!xdr_rpc_gss_buf(xdrs, &databuf, (u_int)-1)) {
 			log_debug("xdr decode databody_integ failed");
 			return (FALSE);
 		}
 		/* Decode checksum. */
-		if (!xdr_bytes(xdrs, (char **)&wrapbuf.value, (u_int *)&wrapbuf.length,
-			       MAX_NETOBJ_SZ)) {
+		if (!xdr_rpc_gss_buf(xdrs, &wrapbuf, (u_int)-1)) {
 			gss_release_buffer(&min_stat, &databuf);
 			log_debug("xdr decode checksum failed");
 			return (FALSE);
@@ -213,8 +244,7 @@ xdr_rpc_gss_unwrap_data(XDR *xdrs, xdrproc_t xdr_func, caddr_t xdr_ptr,
 	}
 	else if (svc == RPCSEC_GSS_SVC_PRIVACY) {
 		/* Decode databody_priv. */
-		if (!xdr_bytes(xdrs, (char **)&wrapbuf.value, (u_int *)&wrapbuf.length,
-			       MAX_NETOBJ_SZ)) {
+		if (!xdr_rpc_gss_buf(xdrs, &wrapbuf, (u_int)-1)) {
 			log_debug("xdr decode databody_priv failed");
 			return (FALSE);
 		}
diff --git a/src/clnt_dg.c b/src/clnt_dg.c
index 79fed5d..4a1f60a 100644
--- a/src/clnt_dg.c
+++ b/src/clnt_dg.c
@@ -366,7 +366,7 @@ call_again:
 
 	if ((! XDR_PUTINT32(xdrs, (int32_t *)&proc)) ||
 	    (! AUTH_MARSHALL(cl->cl_auth, xdrs)) ||
-	    (! (*xargs)(xdrs, argsp))) {
+	    (! AUTH_WRAP(cl->cl_auth, xdrs, xargs, argsp))) {
 		cu->cu_error.re_status = RPC_CANTENCODEARGS;
 		goto out;
 	}
@@ -400,8 +400,8 @@ get_reply:
 	 * (We assume that this is actually only executed once.)
 	 */
 	reply_msg.acpted_rply.ar_verf = _null_auth;
-	reply_msg.acpted_rply.ar_results.where = resultsp;
-	reply_msg.acpted_rply.ar_results.proc = xresults;
+	reply_msg.acpted_rply.ar_results.where = NULL;
+	reply_msg.acpted_rply.ar_results.proc = (xdrproc_t)xdr_void;
 
         fd.fd = cu->cu_fd;
         fd.events = POLLIN;
@@ -512,6 +512,10 @@ get_reply:
 					    &reply_msg.acpted_rply.ar_verf)) {
 				cu->cu_error.re_status = RPC_AUTHERROR;
 				cu->cu_error.re_why = AUTH_INVALIDRESP;
+			} else if (! AUTH_UNWRAP(cl->cl_auth, &reply_xdrs,
+						 xresults, resultsp)) {
+				if (cu->cu_error.re_status == RPC_SUCCESS)
+				     cu->cu_error.re_status = RPC_CANTDECODERES;
 			}
 			if (reply_msg.acpted_rply.ar_verf.oa_base != NULL) {
 				xdrs->x_op = XDR_FREE;
diff --git a/src/clnt_generic.c b/src/clnt_generic.c
index f1dcfa2..b9b07bc 100644
--- a/src/clnt_generic.c
+++ b/src/clnt_generic.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2009, Sun Microsystems, Inc.
+ * Copyright (c) 2010, Oracle America, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -9,7 +9,7 @@
  * - Redistributions in binary form must reproduce the above copyright notice,
  *   this list of conditions and the following disclaimer in the documentation
  *   and/or other materials provided with the distribution.
- * - Neither the name of Sun Microsystems, Inc. nor the names of its
+ * - Neither the name of the "Oracle America, Inc." nor the names of its
  *   contributors may be used to endorse or promote products derived
  *   from this software without specific prior written permission.
  *
@@ -26,10 +26,6 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- * Copyright (c) 1986-1996,1998 by Sun Microsystems, Inc.
- * All rights reserved.
- */
 #include <pthread.h>
 #include <reentrant.h>
 #include <sys/types.h>
diff --git a/src/clnt_vc.c b/src/clnt_vc.c
index 359063c..097cae8 100644
--- a/src/clnt_vc.c
+++ b/src/clnt_vc.c
@@ -364,7 +364,7 @@ call_again:
 	if ((! XDR_PUTBYTES(xdrs, ct->ct_u.ct_mcallc, ct->ct_mpos)) ||
 	    (! XDR_PUTINT32(xdrs, (int32_t *)&proc)) ||
 	    (! AUTH_MARSHALL(cl->cl_auth, xdrs)) ||
-	    (! (*xdr_args)(xdrs, args_ptr))) {
+	    (! AUTH_WRAP(cl->cl_auth, xdrs, xdr_args, args_ptr))) {
 		if (ct->ct_error.re_status == RPC_SUCCESS)
 			ct->ct_error.re_status = RPC_CANTENCODEARGS;
 		(void)xdrrec_endofrecord(xdrs, TRUE);
@@ -420,7 +420,8 @@ call_again:
 		    &reply_msg.acpted_rply.ar_verf)) {
 			ct->ct_error.re_status = RPC_AUTHERROR;
 			ct->ct_error.re_why = AUTH_INVALIDRESP;
-		} else if (! (*xdr_results)(xdrs, results_ptr)) {
+		} else if (! AUTH_UNWRAP(cl->cl_auth, xdrs,
+					 xdr_results, results_ptr)) {
 			if (ct->ct_error.re_status == RPC_SUCCESS)
 				ct->ct_error.re_status = RPC_CANTDECODERES;
 		}
diff --git a/src/getrpcent.c b/src/getrpcent.c
index d7d7ddc..645f18f 100644
--- a/src/getrpcent.c
+++ b/src/getrpcent.c
@@ -46,7 +46,9 @@
 #include <rpcsvc/yp_prot.h>
 #include <rpcsvc/ypclnt.h>
 #endif
+#if defined(__FreeBSD__) || defined(__NetBSD__)
 #include <libc_private.h>
+#endif
 
 /*
  * Internet version.
diff --git a/src/mt_misc.c b/src/mt_misc.c
index 4cba143..fe12c31 100644
--- a/src/mt_misc.c
+++ b/src/mt_misc.c
@@ -123,17 +123,17 @@ __rpc_createerr()
 void tsd_key_delete(void)
 {
 	if (clnt_broadcast_key != -1)
-		thr_keydelete(clnt_broadcast_key);
+		pthread_key_delete(clnt_broadcast_key);
 	if (rpc_call_key != -1)
-		thr_keydelete(rpc_call_key);
+		pthread_key_delete(rpc_call_key);
 	if (tcp_key != -1)
-		thr_keydelete(tcp_key);
+		pthread_key_delete(tcp_key);
 	if (udp_key != -1)
-		thr_keydelete(udp_key);
+		pthread_key_delete(udp_key);
 	if (nc_key != -1)
-		thr_keydelete(nc_key);
+		pthread_key_delete(nc_key);
 	if (rce_key != -1)
-		thr_keydelete(rce_key);
+		pthread_key_delete(rce_key);
 	return;
 }
 
diff --git a/src/rpc_generic.c b/src/rpc_generic.c
index 541275c..509fb36 100644
--- a/src/rpc_generic.c
+++ b/src/rpc_generic.c
@@ -523,7 +523,7 @@ __rpc_nconf2sockinfo(const struct netconfig *nconf, struct __rpc_sockinfo *sip)
 }
 
 int
-__rpc_nconf2fd(const struct netconfig *nconf)
+__rpc_nconf2fd_flags(const struct netconfig *nconf, int flags)
 {
 	struct __rpc_sockinfo si;
 	int fd;
@@ -531,7 +531,7 @@ __rpc_nconf2fd(const struct netconfig *nconf)
 	if (!__rpc_nconf2sockinfo(nconf, &si))
 		return 0;
 
-	if ((fd = socket(si.si_af, si.si_socktype, si.si_proto)) >= 0 &&
+	if ((fd = socket(si.si_af, si.si_socktype | flags, si.si_proto)) >= 0 &&
 	    si.si_af == AF_INET6) {
 		int val = 1;
 
@@ -541,6 +541,12 @@ __rpc_nconf2fd(const struct netconfig *nconf)
 }
 
 int
+__rpc_nconf2fd(const struct netconfig *nconf)
+{
+	return __rpc_nconf2fd_flags(nconf, 0);
+}
+
+int
 __rpc_sockinfo2netid(struct __rpc_sockinfo *sip, const char **netid)
 {
 	int i;
diff --git a/src/rpc_soc.c b/src/rpc_soc.c
index 709a8a8..c678429 100644
--- a/src/rpc_soc.c
+++ b/src/rpc_soc.c
@@ -60,13 +60,14 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <fcntl.h>
 
 #include "rpc_com.h"
 
 extern mutex_t	rpcsoc_lock;
 
 static CLIENT *clnt_com_create(struct sockaddr_in *, rpcprog_t, rpcvers_t,
-    int *, u_int, u_int, char *);
+    int *, u_int, u_int, char *, int);
 static SVCXPRT *svc_com_create(int, u_int, u_int, char *);
 static bool_t rpc_wrap_bcast(char *, struct netbuf *, struct netconfig *);
 
@@ -78,7 +79,7 @@ static bool_t rpc_wrap_bcast(char *, struct netbuf *, struct netconfig *);
  * A common clnt create routine
  */
 static CLIENT *
-clnt_com_create(raddr, prog, vers, sockp, sendsz, recvsz, tp)
+clnt_com_create(raddr, prog, vers, sockp, sendsz, recvsz, tp, flags)
 	struct sockaddr_in *raddr;
 	rpcprog_t prog;
 	rpcvers_t vers;
@@ -86,6 +87,7 @@ clnt_com_create(raddr, prog, vers, sockp, sendsz, recvsz, tp)
 	u_int sendsz;
 	u_int recvsz;
 	char *tp;
+	int flags;
 {
 	CLIENT *cl;
 	int madefd = FALSE;
@@ -100,9 +102,21 @@ clnt_com_create(raddr, prog, vers, sockp, sendsz, recvsz, tp)
 		return (NULL);
 	}
 	if (fd == RPC_ANYSOCK) {
-		fd = __rpc_nconf2fd(nconf);
-		if (fd == -1)
-			goto syserror;
+		static int have_cloexec;
+		fd = __rpc_nconf2fd_flags(nconf, flags);
+		if (fd == -1) {
+			if ((flags & SOCK_CLOEXEC) && have_cloexec <= 0) {
+				fd = __rpc_nconf2fd(nconf);
+				if (fd == -1)
+					goto syserror;
+				if (flags & SOCK_CLOEXEC) {
+					have_cloexec = -1;
+					fcntl(fd, F_SETFD, FD_CLOEXEC);
+				}
+			} else
+				goto syserror;
+		} else if (flags & SOCK_CLOEXEC)
+			have_cloexec = 1;
 		madefd = TRUE;
 	}
 
@@ -154,6 +168,28 @@ err:	if (madefd == TRUE)
 }
 
 CLIENT *
+__libc_clntudp_bufcreate(raddr, prog, vers, wait, sockp, sendsz, recvsz, flags)
+	struct sockaddr_in *raddr;
+	u_long prog;
+	u_long vers;
+	struct timeval wait;
+	int *sockp;
+	u_int sendsz;
+	u_int recvsz;
+	int flags;
+{
+	CLIENT *cl;
+
+	cl = clnt_com_create(raddr, (rpcprog_t)prog, (rpcvers_t)vers, sockp,
+	    sendsz, recvsz, "udp", flags);
+	if (cl == NULL) {
+		return (NULL);
+	}
+	(void) CLNT_CONTROL(cl, CLSET_RETRY_TIMEOUT, &wait);
+	return (cl);
+}
+
+CLIENT *
 clntudp_bufcreate(raddr, prog, vers, wait, sockp, sendsz, recvsz)
 	struct sockaddr_in *raddr;
 	u_long prog;
@@ -166,7 +202,7 @@ clntudp_bufcreate(raddr, prog, vers, wait, sockp, sendsz, recvsz)
 	CLIENT *cl;
 
 	cl = clnt_com_create(raddr, (rpcprog_t)prog, (rpcvers_t)vers, sockp,
-	    sendsz, recvsz, "udp");
+	    sendsz, recvsz, "udp", 0);
 	if (cl == NULL) {
 		return (NULL);
 	}
@@ -195,7 +231,7 @@ clnttcp_create(raddr, prog, vers, sockp, sendsz, recvsz)
 	u_int recvsz;
 {
 	return clnt_com_create(raddr, (rpcprog_t)prog, (rpcvers_t)vers, sockp,
-	    sendsz, recvsz, "tcp");
+	    sendsz, recvsz, "tcp", 0);
 }
 
 /* IPv6 version of clnt*_*create */
@@ -215,7 +251,7 @@ clntudp6_bufcreate(raddr, prog, vers, wait, sockp, sendsz, recvsz)
 	CLIENT *cl;
 
 	cl = clnt_com_create(raddr, (rpcprog_t)prog, (rpcvers_t)vers, sockp,
-	    sendsz, recvsz, "udp6");
+	    sendsz, recvsz, "udp6", 0);
 	if (cl == NULL) {
 		return (NULL);
 	}
@@ -244,7 +280,7 @@ clnttcp6_create(raddr, prog, vers, sockp, sendsz, recvsz)
 	u_int recvsz;
 {
 	return clnt_com_create(raddr, (rpcprog_t)prog, (rpcvers_t)vers, sockp,
-	    sendsz, recvsz, "tcp6");
+	    sendsz, recvsz, "tcp6", 0);
 }
 
 #endif
diff --git a/src/rpcb_clnt.c b/src/rpcb_clnt.c
index 4a3e96c..312967c 100644
--- a/src/rpcb_clnt.c
+++ b/src/rpcb_clnt.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2009, Sun Microsystems, Inc.
+ * Copyright (c) 2010, Oracle America, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -9,7 +9,7 @@
  * - Redistributions in binary form must reproduce the above copyright notice,
  *   this list of conditions and the following disclaimer in the documentation
  *   and/or other materials provided with the distribution.
- * - Neither the name of Sun Microsystems, Inc. nor the names of its
+ * - Neither the name of the "Oracle America, Inc." nor the names of its
  *   contributors may be used to endorse or promote products derived
  *   from this software without specific prior written permission.
  *
@@ -25,15 +25,10 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-/*
- * Copyright (c) 1986-1991 by Sun Microsystems Inc. 
- */
 
 /*
  * rpcb_clnt.c
  * interface to rpcbind rpc service.
- *
- * Copyright (C) 1988, Sun Microsystems, Inc.
  */
 #include <pthread.h>
 #include <reentrant.h>
@@ -56,6 +51,7 @@
 #include <unistd.h>
 #include <netdb.h>
 #include <syslog.h>
+#include <assert.h>
 
 #include "rpc_com.h"
 
@@ -211,14 +207,12 @@ add_cache(host, netid, taddr, uaddr)
 	ad_cache->ac_uaddr = uaddr ? strdup(uaddr) : NULL;
 	ad_cache->ac_taddr = (struct netbuf *)malloc(sizeof (struct netbuf));
 	if (!ad_cache->ac_host || !ad_cache->ac_netid || !ad_cache->ac_taddr ||
-		(uaddr && !ad_cache->ac_uaddr)) {
-		return;
-	}
+			(uaddr && !ad_cache->ac_uaddr))
+		goto out_free;
 	ad_cache->ac_taddr->len = ad_cache->ac_taddr->maxlen = taddr->len;
 	ad_cache->ac_taddr->buf = (char *) malloc(taddr->len);
-	if (ad_cache->ac_taddr->buf == NULL) {
-		return;
-	}
+	if (ad_cache->ac_taddr->buf == NULL)
+		goto out_free;
 	memcpy(ad_cache->ac_taddr->buf, taddr->buf, taddr->len);
 #ifdef ND_DEBUG
 	fprintf(stderr, "Added to cache: %s : %s\n", host, netid);
@@ -262,6 +256,14 @@ add_cache(host, netid, taddr, uaddr)
 		free(cptr);
 	}
 	rwlock_unlock(&rpcbaddr_cache_lock);
+	return;
+
+out_free:
+	free(ad_cache->ac_host);
+	free(ad_cache->ac_netid);
+	free(ad_cache->ac_uaddr);
+	free(ad_cache->ac_taddr);
+	free(ad_cache);
 }
 
 /*
@@ -289,6 +291,8 @@ getclnthandle(host, nconf, targaddr)
 
 	/* Get the address of the rpcbind.  Check cache first */
 	client = NULL;
+	if (targaddr)
+		*targaddr = NULL;
 	addr_to_delete.len = 0;
 	rwlock_rdlock(&rpcbaddr_cache_lock);
 	ad_cache = NULL;
@@ -325,7 +329,8 @@ getclnthandle(host, nconf, targaddr)
 	}
 	if (!__rpc_nconf2sockinfo(nconf, &si)) {
 		rpc_createerr.cf_stat = RPC_UNKNOWNPROTO;
-		return NULL;
+		assert(client == NULL);
+		goto out_err;
 	}
 
 	memset(&hints, 0, sizeof hints);
@@ -344,7 +349,7 @@ getclnthandle(host, nconf, targaddr)
 #ifdef ND_DEBUG
 			clnt_pcreateerror("rpcbind clnt interface");
 #endif
-			return (NULL);
+			goto out_err;
 		} else {
 			struct sockaddr_un sun;
 
@@ -356,7 +361,8 @@ getclnthandle(host, nconf, targaddr)
 	} else {
 		if (getaddrinfo(host, "sunrpc", &hints, &res) != 0) {
 			rpc_createerr.cf_stat = RPC_UNKNOWNHOST;
-			return NULL;
+			assert(client == NULL);
+			goto out_err;
 		}
 	}
 
@@ -404,6 +410,9 @@ getclnthandle(host, nconf, targaddr)
 	}
 	if (res)
 		freeaddrinfo(res);
+out_err:
+	if (!client && targaddr)
+		free(*targaddr);
 	return (client);
 }
 
diff --git a/src/svc.c b/src/svc.c
index cc65e6a..08cd6c9 100644
--- a/src/svc.c
+++ b/src/svc.c
@@ -77,9 +77,6 @@ static struct svc_callout
 
 extern rwlock_t svc_lock;
 extern rwlock_t svc_fd_lock;
-#ifdef HAVE_LIBGSSAPI
-extern struct svc_auth_ops svc_auth_gss_ops;
-#endif
 
 static struct svc_callout *svc_find (rpcprog_t, rpcvers_t,
 				     struct svc_callout **, char *);
@@ -615,7 +612,7 @@ svc_getreqset (readfds)
   maskp = readfds->fds_bits;
   for (sock = 0; sock < FD_SETSIZE; sock += NFDBITS)
     {
-      for (mask = *maskp++; (bit = ffs (mask)) != 0; mask ^= (1 << (bit - 1)))
+      for (mask = *maskp++; (bit = ffsl(mask)) != 0; mask ^= (1L << (bit - 1)))
 	{
 	  /* sock has input waiting */
 	  fd = sock + bit - 1;
@@ -717,11 +714,9 @@ svc_getreq_common (fd)
 	  SVC_DESTROY (xprt);
 	  break;
 	}
-    else if ((xprt->xp_auth != NULL) 
-#ifdef HAVE_LIBGSSAPI
-	  	&& (xprt->xp_auth->svc_ah_ops != &svc_auth_gss_ops)
-#endif
-	) {
+    else if ((xprt->xp_auth != NULL) &&
+	     (xprt->xp_auth->svc_ah_private == NULL))
+	{
 	  xprt->xp_auth = NULL;
 	}
     }
diff --git a/src/svc_auth.c b/src/svc_auth.c
index c6b3a0b..e80d5f9 100644
--- a/src/svc_auth.c
+++ b/src/svc_auth.c
@@ -98,8 +98,8 @@ _authenticate(rqst, msg)
 	rqst->rq_xprt->xp_verf.oa_length = 0;
 	cred_flavor = rqst->rq_cred.oa_flavor;
 	switch (cred_flavor) {
-	case AUTH_NULL:
-		dummy = _svcauth_null(rqst, msg);
+	case AUTH_NONE:
+		dummy = _svcauth_none(rqst, msg);
 		return (dummy);
 	case AUTH_SYS:
 		dummy = _svcauth_unix(rqst, msg);
@@ -132,15 +132,6 @@ _authenticate(rqst, msg)
 	return (AUTH_REJECTEDCRED);
 }
 
-/*ARGSUSED*/
-enum auth_stat
-_svcauth_null(rqst, msg)
-	struct svc_req *rqst;
-	struct rpc_msg *msg;
-{
-	return (AUTH_OK);
-}
-
 /*
  *  Allow the rpc service to register new authentication types that it is
  *  prepared to handle.  When an authentication flavor is registered,
diff --git a/src/svc_auth_des.c b/src/svc_auth_des.c
index 479334f..e0ff6cb 100644
--- a/src/svc_auth_des.c
+++ b/src/svc_auth_des.c
@@ -60,7 +60,9 @@
 #include <rpc/svc.h>
 #include <rpc/rpc_msg.h>
 #include <rpc/svc_auth.h>
+#if defined(__FreeBSD__) || defined(__NetBSD__)
 #include <libc_private.h>
+#endif
 
 extern int key_decryptsession_pk(const char *, netobj *, des_block *);
 
diff --git a/src/svc_auth_unix.c b/src/svc_auth_unix.c
index ce83859..9585069 100644
--- a/src/svc_auth_unix.c
+++ b/src/svc_auth_unix.c
@@ -43,6 +43,8 @@
 
 #include <rpc/rpc.h>
 
+extern SVCAUTH svc_auth_none;
+
 /*
  * Unix longhand authenticator
  */
@@ -67,6 +69,8 @@ _svcauth_unix(rqst, msg)
 	assert(rqst != NULL);
 	assert(msg != NULL);
 
+	rqst->rq_xprt->xp_auth = &svc_auth_none;
+
 	area = (struct area *) rqst->rq_clntcred;
 	aup = &area->area_aup;
 	aup->aup_machname = area->area_machname;
@@ -142,5 +146,6 @@ _svcauth_short(rqst, msg)
 	struct svc_req *rqst;
 	struct rpc_msg *msg;
 {
+	rqst->rq_xprt->xp_auth = &svc_auth_none;
 	return (AUTH_REJECTEDCRED);
 }
diff --git a/src/svc_dg.c b/src/svc_dg.c
index a179b80..081db61 100644
--- a/src/svc_dg.c
+++ b/src/svc_dg.c
@@ -75,6 +75,8 @@ static bool_t svc_dg_control(SVCXPRT *, const u_int, void *);
 static int cache_get(SVCXPRT *, struct rpc_msg *, char **, size_t *);
 static void cache_set(SVCXPRT *, size_t);
 int svc_dg_enablecache(SVCXPRT *, u_int);
+static void svc_dg_enable_pktinfo(int, const struct __rpc_sockinfo *);
+static int svc_dg_valid_pktinfo(struct msghdr *);
 
 /*
  * Usage:
@@ -132,6 +134,7 @@ svc_dg_create(fd, sendsize, recvsize)
 	su->su_cache = NULL;
 	xprt->xp_fd = fd;
 	xprt->xp_p2 = su;
+	xprt->xp_auth = NULL;
 	xprt->xp_verf.oa_base = su->su_verfbody;
 	svc_dg_ops(xprt);
 	xprt->xp_rtaddr.maxlen = sizeof (struct sockaddr_storage);
@@ -141,6 +144,9 @@ svc_dg_create(fd, sendsize, recvsize)
 		goto freedata;
 	__rpc_set_netbuf(&xprt->xp_ltaddr, &ss, slen);
 
+	/* Enable reception of IP*_PKTINFO control msgs */
+	svc_dg_enable_pktinfo(fd, &si);
+
 	xprt_register(xprt);
 	return (xprt);
 freedata:
@@ -170,19 +176,36 @@ svc_dg_recv(xprt, msg)
 	XDR *xdrs = &(su->su_xdrs);
 	char *reply;
 	struct sockaddr_storage ss;
-	socklen_t alen;
+	struct msghdr *mesgp;
+	struct iovec iov;
 	size_t replylen;
 	ssize_t rlen;
 
 again:
-	alen = sizeof (struct sockaddr_storage);
-	rlen = recvfrom(xprt->xp_fd, rpc_buffer(xprt), su->su_iosz, 0,
-	    (struct sockaddr *)(void *)&ss, &alen);
+	iov.iov_base = rpc_buffer(xprt);
+	iov.iov_len = su->su_iosz;
+	mesgp = &su->su_msghdr;
+	memset(mesgp, 0, sizeof(*mesgp));
+	mesgp->msg_iov = &iov;
+	mesgp->msg_iovlen = 1;
+	mesgp->msg_name = (struct sockaddr *)(void *) &ss;
+	mesgp->msg_namelen = sizeof (struct sockaddr_storage);
+	mesgp->msg_control = su->su_cmsg;
+	mesgp->msg_controllen = sizeof(su->su_cmsg);
+
+	rlen = recvmsg(xprt->xp_fd, mesgp, 0);
 	if (rlen == -1 && errno == EINTR)
 		goto again;
 	if (rlen == -1 || (rlen < (ssize_t)(4 * sizeof (u_int32_t))))
 		return (FALSE);
-	__rpc_set_netbuf(&xprt->xp_rtaddr, &ss, alen);
+	__rpc_set_netbuf(&xprt->xp_rtaddr, &ss, mesgp->msg_namelen);
+
+	/* Check whether there's an IP_PKTINFO or IP6_PKTINFO control message.
+	 * If yes, preserve it for svc_dg_reply; otherwise just zap any cmsgs */
+	if (!svc_dg_valid_pktinfo(mesgp)) {
+		mesgp->msg_control = NULL;
+		mesgp->msg_controllen = 0;
+	}
 
 	__xprt_set_raddr(xprt, &ss);
 	xdrs->x_op = XDR_DECODE;
@@ -193,8 +216,9 @@ again:
 	su->su_xid = msg->rm_xid;
 	if (su->su_cache != NULL) {
 		if (cache_get(xprt, msg, &reply, &replylen)) {
-			(void)sendto(xprt->xp_fd, reply, replylen, 0,
-			    (struct sockaddr *)(void *)&ss, alen);
+			iov.iov_base = reply;
+			iov.iov_len = replylen;
+			(void) sendmsg(xprt->xp_fd, mesgp, 0);
 			return (FALSE);
 		}
 	}
@@ -211,14 +235,39 @@ svc_dg_reply(xprt, msg)
 	bool_t stat = FALSE;
 	size_t slen;
 
+	xdrproc_t xdr_results;
+	caddr_t xdr_location;
+	bool_t has_args;
+
+	if (msg->rm_reply.rp_stat == MSG_ACCEPTED &&
+	    msg->rm_reply.rp_acpt.ar_stat == SUCCESS) {
+		has_args = TRUE;
+		xdr_results = msg->acpted_rply.ar_results.proc;
+		xdr_location = msg->acpted_rply.ar_results.where;
+
+		msg->acpted_rply.ar_results.proc = (xdrproc_t)xdr_void;
+		msg->acpted_rply.ar_results.where = NULL;
+	} else
+		has_args = FALSE;
+
 	xdrs->x_op = XDR_ENCODE;
 	XDR_SETPOS(xdrs, 0);
 	msg->rm_xid = su->su_xid;
-	if (xdr_replymsg(xdrs, msg)) {
-		slen = XDR_GETPOS(xdrs);
-		if (sendto(xprt->xp_fd, rpc_buffer(xprt), slen, 0,
-		    (struct sockaddr *)xprt->xp_rtaddr.buf,
-		    (socklen_t)xprt->xp_rtaddr.len) == (ssize_t) slen) {
+	if (xdr_replymsg(xdrs, msg) &&
+	    (!has_args || (xprt->xp_auth &&
+	     SVCAUTH_WRAP(xprt->xp_auth, xdrs, xdr_results, xdr_location)))) {
+		struct msghdr *msg = &su->su_msghdr;
+		struct iovec iov;
+
+		iov.iov_base = rpc_buffer(xprt);
+		iov.iov_len = slen = XDR_GETPOS(xdrs);
+		msg->msg_iov = &iov;
+		msg->msg_iovlen = 1;
+		msg->msg_name = (struct sockaddr *)(void *) xprt->xp_rtaddr.buf;
+		msg->msg_namelen = xprt->xp_rtaddr.len;
+		/* cmsg already set in svc_dg_recv */
+
+		if (sendmsg(xprt->xp_fd, msg, 0) == (ssize_t) slen) {
 			stat = TRUE;
 			if (su->su_cache)
 				cache_set(xprt, slen);
@@ -233,7 +282,12 @@ svc_dg_getargs(xprt, xdr_args, args_ptr)
 	xdrproc_t xdr_args;
 	void *args_ptr;
 {
-	return (*xdr_args)(&(su_data(xprt)->su_xdrs), args_ptr);
+	if (! SVCAUTH_UNWRAP(xprt->xp_auth, &(su_data(xprt)->su_xdrs),
+			     xdr_args, args_ptr)) {
+		(void)svc_freeargs(xprt, xdr_args, args_ptr);
+		return FALSE;
+	}
+	return TRUE;
 }
 
 static bool_t
@@ -257,6 +311,10 @@ svc_dg_destroy(xprt)
 	xprt_unregister(xprt);
 	if (xprt->xp_fd != -1)
 		(void)close(xprt->xp_fd);
+	if (xprt->xp_auth != NULL) {
+		SVCAUTH_DESTROY(xprt->xp_auth);
+		xprt->xp_auth = NULL;
+	}
 	XDR_DESTROY(&(su->su_xdrs));
 	(void) mem_free(rpc_buffer(xprt), su->su_iosz);
 	(void) mem_free(su, sizeof (*su));
@@ -582,3 +640,76 @@ cache_get(xprt, msg, replyp, replylenp)
 	mutex_unlock(&dupreq_lock);
 	return (0);
 }
+
+/*
+ * Enable reception of PKTINFO control messages
+ */
+void
+svc_dg_enable_pktinfo(int fd, const struct __rpc_sockinfo *si)
+{
+	int val = 1;
+
+	switch (si->si_af) {
+	case AF_INET:
+		(void) setsockopt(fd, SOL_IP, IP_PKTINFO, &val, sizeof(val));
+		break;
+
+	case AF_INET6:
+		(void) setsockopt(fd, SOL_IPV6, IPV6_PKTINFO, &val, sizeof(val));
+		break;
+	}
+}
+
+/*
+ * When given a control message received from the socket
+ * layer, check whether it contains valid PKTINFO data matching
+ * the address family of the peer address.
+ */
+int
+svc_dg_valid_pktinfo(struct msghdr *msg)
+{
+	struct cmsghdr *cmsg;
+
+	if (!msg->msg_name)
+		return 0;
+
+	if (msg->msg_flags & MSG_CTRUNC)
+		return 0;
+
+	cmsg = CMSG_FIRSTHDR(msg);
+	if (cmsg == NULL || CMSG_NXTHDR(msg, cmsg) != NULL)
+		return 0;
+
+	switch (((struct sockaddr *) msg->msg_name)->sa_family) {
+	case AF_INET:
+		if (cmsg->cmsg_level != SOL_IP
+		 || cmsg->cmsg_type != IP_PKTINFO
+		 || cmsg->cmsg_len < CMSG_LEN(sizeof (struct in_pktinfo))) {
+			return 0;
+		} else {
+			struct in_pktinfo *pkti;
+			
+			pkti = (struct in_pktinfo *) CMSG_DATA (cmsg);
+			pkti->ipi_ifindex = 0;
+		}
+		break;
+
+	case AF_INET6:
+		if (cmsg->cmsg_level != SOL_IPV6
+		 || cmsg->cmsg_type != IPV6_PKTINFO
+		 || cmsg->cmsg_len < CMSG_LEN(sizeof (struct in6_pktinfo))) {
+			return 0;
+		} else {
+			struct in6_pktinfo *pkti;
+			
+			pkti = (struct in6_pktinfo *) CMSG_DATA (cmsg);
+			pkti->ipi6_ifindex = 0;
+		}
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
diff --git a/src/svc_vc.c b/src/svc_vc.c
index 8e39597..4c70de8 100644
--- a/src/svc_vc.c
+++ b/src/svc_vc.c
@@ -172,6 +172,7 @@ svc_vc_create(fd, sendsize, recvsize)
 	xprt->xp_p1 = r;
 	xprt->xp_p2 = NULL;
 	xprt->xp_p3 = NULL;
+	xprt->xp_auth = NULL;
 	xprt->xp_verf = _null_auth;
 	svc_vc_rendezvous_ops(xprt);
 	xprt->xp_port = (u_short)-1;	/* It is the rendezvouser */
@@ -283,6 +284,7 @@ makefd_xprt(fd, sendsize, recvsize)
 	xdrrec_create(&(cd->xdrs), sendsize, recvsize,
 	    xprt, read_vc, write_vc);
 	xprt->xp_p1 = cd;
+	xprt->xp_auth = NULL;
 	xprt->xp_verf.oa_base = cd->verf_body;
 	svc_vc_ops(xprt);  /* truely deals with calls */
 	xprt->xp_port = 0;  /* this is a connection, not a rendezvouser */
@@ -412,6 +414,10 @@ __svc_vc_dodestroy(xprt)
 		XDR_DESTROY(&(cd->xdrs));
 		mem_free(cd, sizeof(struct cf_conn));
 	}
+	if (xprt->xp_auth != NULL) {
+		SVCAUTH_DESTROY(xprt->xp_auth);
+		xprt->xp_auth = NULL;
+	}
 	if (xprt->xp_rtaddr.buf)
 		mem_free(xprt->xp_rtaddr.buf, xprt->xp_rtaddr.maxlen);
 	if (xprt->xp_ltaddr.buf)
@@ -610,7 +616,11 @@ svc_vc_recv(xprt, msg)
 	}
 
 	xdrs->x_op = XDR_DECODE;
-	(void)xdrrec_skiprecord(xdrs);
+	/*
+	 * No need skip records with nonblocking connections
+	 */
+	if (cd->nonblock == FALSE)
+		(void)xdrrec_skiprecord(xdrs);
 	if (xdr_callmsg(xdrs, msg)) {
 		cd->x_id = msg->rm_xid;
 		return (TRUE);
@@ -628,8 +638,13 @@ svc_vc_getargs(xprt, xdr_args, args_ptr)
 
 	assert(xprt != NULL);
 	/* args_ptr may be NULL */
-	return ((*xdr_args)(&(((struct cf_conn *)(xprt->xp_p1))->xdrs),
-	    args_ptr));
+
+	if (! SVCAUTH_UNWRAP(xprt->xp_auth,
+			     &(((struct cf_conn *)(xprt->xp_p1))->xdrs),
+			     xdr_args, args_ptr)) {
+		return FALSE;  
+	}
+	return TRUE;
 }
 
 static bool_t
@@ -658,15 +673,35 @@ svc_vc_reply(xprt, msg)
 	XDR *xdrs;
 	bool_t rstat;
 
+	xdrproc_t xdr_results;
+	caddr_t xdr_location;
+	bool_t has_args;
+
 	assert(xprt != NULL);
 	assert(msg != NULL);
 
 	cd = (struct cf_conn *)(xprt->xp_p1);
 	xdrs = &(cd->xdrs);
 
+	if (msg->rm_reply.rp_stat == MSG_ACCEPTED &&
+	    msg->rm_reply.rp_acpt.ar_stat == SUCCESS) {
+		has_args = TRUE;
+		xdr_results = msg->acpted_rply.ar_results.proc;
+		xdr_location = msg->acpted_rply.ar_results.where;
+
+		msg->acpted_rply.ar_results.proc = (xdrproc_t)xdr_void;
+		msg->acpted_rply.ar_results.where = NULL;
+	} else
+		has_args = FALSE;
+
 	xdrs->x_op = XDR_ENCODE;
 	msg->rm_xid = cd->x_id;
-	rstat = xdr_replymsg(xdrs, msg);
+	rstat = FALSE;
+	if (xdr_replymsg(xdrs, msg) &&
+	    (!has_args || (xprt->xp_auth &&
+	     SVCAUTH_WRAP(xprt->xp_auth, xdrs, xdr_results, xdr_location)))) {
+		rstat = TRUE;
+	}
 	(void)xdrrec_endofrecord(xdrs, TRUE);
 	return (rstat);
 }
@@ -748,6 +783,10 @@ __rpc_get_local_uid(SVCXPRT *transp, uid_t *uid) {
  * Destroy xprts that have not have had any activity in 'timeout' seconds.
  * If 'cleanblock' is true, blocking connections (the default) are also
  * cleaned. If timeout is 0, the least active connection is picked.
+ *
+ * Though this is not a publicly documented interface, some versions of
+ * rpcbind are known to call this function.  Do not alter or remove this
+ * API without changing the library's sonum.
  */
 bool_t
 __svc_clean_idle(fd_set *fds, int timeout, bool_t cleanblock)
diff --git a/src/xdr_rec.c b/src/xdr_rec.c
index 4e815d7..2aca623 100644
--- a/src/xdr_rec.c
+++ b/src/xdr_rec.c
@@ -64,7 +64,6 @@
 #include <rpc/clnt.h>
 #include <stddef.h>
 #include "rpc_com.h"
-#include <unistd.h>
 static bool_t	xdrrec_getlong(XDR *, long *);
 static bool_t	xdrrec_putlong(XDR *, const long *);
 static bool_t	xdrrec_getbytes(XDR *, char *, u_int);
@@ -330,22 +329,22 @@ xdrrec_getpos(xdrs)
 	RECSTREAM *rstrm = (RECSTREAM *)xdrs->x_private;
 	off_t pos;
 
-	pos = lseek((int)(u_long)rstrm->tcp_handle, (off_t)0, 1);
-	if (pos != -1)
-		switch (xdrs->x_op) {
+	switch (xdrs->x_op) {
 
-		case XDR_ENCODE:
-			pos += rstrm->out_finger - rstrm->out_base;
-			break;
+	case XDR_ENCODE:
+		pos = rstrm->out_finger - rstrm->out_base
+			- BYTES_PER_XDR_UNIT;
+		break;
 
-		case XDR_DECODE:
-			pos -= rstrm->in_boundry - rstrm->in_finger;
-			break;
+	case XDR_DECODE:
+		pos = rstrm->in_boundry - rstrm->in_finger
+			- BYTES_PER_XDR_UNIT;
+		break;
 
-		default:
-			pos = (off_t) -1;
-			break;
-		}
+	default:
+		pos = (off_t) -1;
+		break;
+	}
 	return ((u_int) pos);
 }
 
diff --git a/src/xdr_reference.c b/src/xdr_reference.c
index 821dc8e..1da2c14 100644
--- a/src/xdr_reference.c
+++ b/src/xdr_reference.c
@@ -46,7 +46,10 @@
 
 #include <rpc/types.h>
 #include <rpc/xdr.h>
-#include "libc_private.h"
+
+#if defined(__FreeBSD__) || defined(__NetBSD__)
+#include <libc_private.h>
+#endif
 
 /*
  * XDR an indirect pointer
diff --git a/tirpc/libc_private.h b/tirpc/libc_private.h
index 63f8610..e69de29 100644
--- a/tirpc/libc_private.h
+++ b/tirpc/libc_private.h
@@ -1,129 +0,0 @@
-/*
- * Copyright (c) 1998 John Birrell <jb@cimlogic.com.au>.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by John Birrell.
- * 4. Neither the name of the author nor the names of any co-contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY JOHN BIRRELL AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * $FreeBSD: src/lib/libc/include/libc_private.h,v 1.11 2003/11/05 18:17:30 deischen Exp $
- *
- * Private definitions for libc, libc_r and libpthread.
- *
- */
-
-#ifndef _LIBC_PRIVATE_H_
-#define _LIBC_PRIVATE_H_
-
-/*
- * This global flag is non-zero when a process has created one
- * or more threads. It is used to avoid calling locking functions
- * when they are not required.
- */
-extern int	__isthreaded;
-
-/*
- * File lock contention is difficult to diagnose without knowing
- * where locks were set. Allow a debug library to be built which
- * records the source file and line number of each lock call.
- */
-#ifdef	_FLOCK_DEBUG
-#define _FLOCKFILE(x)	_flockfile_debug(x, __FILE__, __LINE__)
-#else
-#define _FLOCKFILE(x)	_flockfile(x)
-#endif
-
-/*
- * Macros for locking and unlocking FILEs. These test if the
- * process is threaded to avoid locking when not required.
- */
-#define	FLOCKFILE(fp)		if (__isthreaded) _FLOCKFILE(fp)
-#define	FUNLOCKFILE(fp)		if (__isthreaded) _funlockfile(fp)
-
-/*
- * Indexes into the pthread jump table.
- *
- * Warning! If you change this type, you must also change the threads
- * libraries that reference it (libc_r, libpthread).
- */
-typedef enum {
-	PJT_COND_BROADCAST,
-	PJT_COND_DESTROY,
-	PJT_COND_INIT,
-	PJT_COND_SIGNAL,
-	PJT_COND_WAIT,
-	PJT_GETSPECIFIC,
-	PJT_KEY_CREATE,
-	PJT_KEY_DELETE,
-	PJT_MAIN_NP,
-	PJT_MUTEX_DESTROY,
-	PJT_MUTEX_INIT,
-	PJT_MUTEX_LOCK,
-	PJT_MUTEX_TRYLOCK,
-	PJT_MUTEX_UNLOCK,
-	PJT_MUTEXATTR_DESTROY,
-	PJT_MUTEXATTR_INIT,
-	PJT_MUTEXATTR_SETTYPE,
-	PJT_ONCE,
-	PJT_RWLOCK_DESTROY,
-	PJT_RWLOCK_INIT,
-	PJT_RWLOCK_RDLOCK,
-	PJT_RWLOCK_TRYRDLOCK,
-	PJT_RWLOCK_TRYWRLOCK,
-	PJT_RWLOCK_UNLOCK,
-	PJT_RWLOCK_WRLOCK,
-	PJT_SELF,
-	PJT_SETSPECIFIC,
-	PJT_SIGMASK,
-	PJT_MAX
-} pjt_index_t;
-
-typedef int (*pthread_func_t)(void);
-typedef pthread_func_t pthread_func_entry_t[2];
-
-extern pthread_func_entry_t __thr_jtable[];
-
-/*
- * yplib internal interfaces
- */
-#ifdef YP
-int _yp_check(char **);
-#endif
-
-
-/*
- * This is a pointer in the C run-time startup code. It is used
- * by getprogname() and setprogname().
- */
-extern const char *__progname;
-
-/*
- * This is the lock to make malloc() thread-safe.  It is externalized
- * so that thread libraries can protect malloc across fork().
- */
-extern struct _spinlock *__malloc_lock;
-
-#endif /* _LIBC_PRIVATE_H_ */
diff --git a/tirpc/nss_tls.h b/tirpc/nss_tls.h
index 7536736..e69de29 100644
--- a/tirpc/nss_tls.h
+++ b/tirpc/nss_tls.h
@@ -1,80 +0,0 @@
-/*-
- * Copyright (c) 2003 Networks Associates Technology, Inc.
- * All rights reserved.
- *
- * This software was developed for the FreeBSD Project by
- * Jacques A. Vidrine, Safeport Network Services, and Network
- * Associates Laboratories, the Security Research Division of Network
- * Associates, Inc. under DARPA/SPAWAR contract N66001-01-C-8035
- * ("CBOSS"), as part of the DARPA CHATS research program.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * $FreeBSD: src/lib/libc/include/nss_tls.h,v 1.2 2003/04/21 15:44:25 nectar Exp $
- *
- * Macros which generate thread local storage handling code in NSS modules.
- */
-#ifndef _NSS_TLS_H_
-#define _NSS_TLS_H_
-
-#define NSS_TLS_HANDLING(name)					\
-static pthread_key_t name##_state_key;				\
-static	void	 name##_keyinit(void);				\
-static	int	 name##_getstate(struct name##_state **);	\
-\
-static void								\
-name##_keyinit(void)							\
-{									\
-	(void)_pthread_key_create(&name##_state_key, name##_endstate);	\
-}									\
-\
-static int							\
-name##_getstate(struct name##_state **p)			\
-{								\
-	static struct name##_state st;				\
-	static pthread_once_t	keyinit = PTHREAD_ONCE_INIT;	\
-	int			rv;				\
-								\
-	if (!__isthreaded || _pthread_main_np() != 0) {		\
-		*p = &st;					\
-		return (0);					\
-	}							\
-	rv = _pthread_once(&keyinit, name##_keyinit);		\
-	if (rv != 0)						\
-		return (rv);					\
-	*p = _pthread_getspecific(name##_state_key);		\
-	if (*p != NULL)						\
-		return (0);					\
-	*p = calloc(1, sizeof(**p));				\
-	if (*p == NULL)						\
-		return (ENOMEM);				\
-	rv = _pthread_setspecific(name##_state_key, *p);	\
-	if (rv != 0) {						\
-		free(*p);					\
-		*p = NULL;					\
-	}							\
-	return (rv);						\
-}								\
-/* allow the macro invocation to end with a semicolon */	\
-typedef int _##name##_bmVjdGFy
-
-#endif /* _NSS_TLS_H_ */
diff --git a/tirpc/reentrant.h b/tirpc/reentrant.h
index fda8f65..9489b15 100644
--- a/tirpc/reentrant.h
+++ b/tirpc/reentrant.h
@@ -13,13 +13,6 @@
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *        This product includes software developed by the NetBSD
- *        Foundation, Inc. and its contributors.
- * 4. Neither the name of The NetBSD Foundation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
@@ -33,95 +26,51 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  *
- * $FreeBSD: src/lib/libc/include/reentrant.h,v 1.2 2002/11/01 09:37:17 dfr Exp $
  */
 
-/*
- * Requirements:
- * 
- * 1. The thread safe mechanism should be lightweight so the library can
- *    be used by non-threaded applications without unreasonable overhead.
- * 
- * 2. There should be no dependency on a thread engine for non-threaded
- *    applications.
- * 
- * 3. There should be no dependency on any particular thread engine.
- * 
- * 4. The library should be able to be compiled without support for thread
- *    safety.
- * 
- * 
- * Rationale:
- * 
- * One approach for thread safety is to provide discrete versions of the
- * library: one thread safe, the other not.  The disadvantage of this is
- * that libc is rather large, and two copies of a library which are 99%+
- * identical is not an efficent use of resources.
- * 
- * Another approach is to provide a single thread safe library.  However,
- * it should not add significant run time or code size overhead to non-
- * threaded applications.
- * 
- * Since the NetBSD C library is used in other projects, it should be
- * easy to replace the mutual exclusion primitives with ones provided by
- * another system.  Similarly, it should also be easy to remove all
- * support for thread safety completely if the target environment does
- * not support threads.
- * 
- * 
- * Implementation Details:
- * 
- * The mutex primitives used by the library (mutex_t, mutex_lock, etc.)
- * are macros which expand to the cooresponding primitives provided by
- * the thread engine or to nothing.  The latter is used so that code is
- * not unreasonably cluttered with #ifdefs when all thread safe support
- * is removed.
- * 
- * The mutex macros can be directly mapped to the mutex primitives from
- * pthreads, however it should be reasonably easy to wrap another mutex
- * implementation so it presents a similar interface.
- * 
- * Stub implementations of the mutex functions are provided with *weak*
- * linkage.  These functions simply return success.  When linked with a
- * thread library (i.e. -lpthread), the functions will override the
- * stubs.
+/* 
+ * This file was derived from a copy in FreeBSD CVS on August 26, 2010. 
+ * FreeBSD/NetBSD have slightly different definitions for some/most of
+ * these functions and types, so they should just use the ones found
+ * in their system copy of reentrant.h.
+ * These definitions are only guaranteed to be valid on Linux. 
  */
-#ifndef _REENTRANT_H
-#define _REENTRANT_H
-#include <pthread.h>
-#include <libc_private.h>
 
-#include <stdlib.h>
+#if defined(__linux__)
+
+#include <pthread.h>
 
 #define mutex_t			pthread_mutex_t
 #define cond_t			pthread_cond_t
 #define rwlock_t		pthread_rwlock_t
+#define once_t			pthread_once_t
 
 #define thread_key_t		pthread_key_t
 #define MUTEX_INITIALIZER	PTHREAD_MUTEX_INITIALIZER
 #define RWLOCK_INITIALIZER	PTHREAD_RWLOCK_INITIALIZER
+#define ONCE_INITIALIZER	PTHREAD_ONCE_INIT
+
 #define mutex_init(m, a)	pthread_mutex_init(m, a)
 #define mutex_lock(m)		pthread_mutex_lock(m)
 #define mutex_unlock(m)		pthread_mutex_unlock(m)
-#define mutex_trylock(m)	pthread_mutex_trylock(m)
 
-#define cond_init(c, a, p)	 pthread_cond_init(c, a)
-#define cond_signal(m)		 pthread_cond_signal(m)
-#define cond_broadcast(m)	 pthread_cond_broadcast(m)
-#define cond_wait(c, m)		 pthread_cond_wait(c, m)
+#define cond_init(c, a, p)	pthread_cond_init(c, a)
+#define cond_signal(m)		pthread_cond_signal(m)
+#define cond_broadcast(m)	pthread_cond_broadcast(m)
+#define cond_wait(c, m)		pthread_cond_wait(c, m)
 
-#define rwlock_init(l, a)        pthread_rwlock_init(l, a)
-#define rwlock_rdlock(l)	 pthread_rwlock_rdlock(l)
-#define rwlock_wrlock(l)	 pthread_rwlock_wrlock(l)
-#define rwlock_unlock(l)	 pthread_rwlock_unlock(l)
+#define rwlock_init(l, a)	pthread_rwlock_init(l, a)
+#define rwlock_rdlock(l)	pthread_rwlock_rdlock(l)
+#define rwlock_wrlock(l)	pthread_rwlock_wrlock(l)
+#define rwlock_unlock(l)	pthread_rwlock_unlock(l)
 
-#define thr_keycreate(k, d)	 pthread_key_create(k, d)
-#define thr_keydelete(k)	 pthread_key_delete(k)
-#define thr_setspecific(k, p)	 pthread_setspecific(k, p)
-#define thr_getspecific(k)	 pthread_getspecific(k)
-#define thr_sigsetmask(f, n, o)	 pthread_sigmask(f, n, o)
+#define thr_keycreate(k, d)	pthread_key_create(k, d)
+#define thr_setspecific(k, p)	pthread_setspecific(k, p)
+#define thr_getspecific(k)	pthread_getspecific(k)
+#define thr_sigsetmask(f, n, o)	pthread_sigmask(f, n, o)
 
-#define thr_self()		 pthread_self()
-#define thr_exit(x)		 pthread_exit(x)
+#define thr_once(o, i)		pthread_once(o, i)
+#define thr_self()		pthread_self()
+#define thr_exit(x)		pthread_exit(x)
 
-#endif /* reentrant.h */
+#endif
diff --git a/tirpc/rpc/auth.h b/tirpc/rpc/auth.h
index 734e6b9..5f66e67 100644
--- a/tirpc/rpc/auth.h
+++ b/tirpc/rpc/auth.h
@@ -203,8 +203,22 @@ typedef struct __auth {
 
 	} *ah_ops;
 	void *ah_private;
+	int ah_refcnt;
 } AUTH;
 
+static __inline int
+auth_get(AUTH *auth)
+{
+	return __sync_add_and_fetch(&auth->ah_refcnt, 1);
+}
+
+static __inline int
+auth_put(AUTH *auth)
+{
+	return __sync_sub_and_fetch(&auth->ah_refcnt, 1);
+}
+
+
 
 /*
  * Authentication ops.
@@ -234,10 +248,23 @@ typedef struct __auth {
 #define auth_refresh(auth, msg)		\
 		((*((auth)->ah_ops->ah_refresh))(auth, msg))
 
-#define AUTH_DESTROY(auth)		\
-		((*((auth)->ah_ops->ah_destroy))(auth))
-#define auth_destroy(auth)		\
-		((*((auth)->ah_ops->ah_destroy))(auth))
+#define AUTH_DESTROY(auth)						\
+		do {							\
+			int refs;					\
+			if ((refs = auth_put((auth))) == 0)		\
+				((*((auth)->ah_ops->ah_destroy))(auth));\
+			log_debug("%s: auth_put(), refs %d\n",		\
+				__func__, refs);			\
+		} while (0)
+
+#define auth_destroy(auth)						\
+		do {							\
+			int refs;					\
+			if ((refs = auth_put((auth))) == 0)		\
+				((*((auth)->ah_ops->ah_destroy))(auth));\
+			log_debug("%s: auth_put(), refs %d\n",		\
+				__func__, refs);			\
+		} while (0)
 
 #define AUTH_WRAP(auth, xdrs, xfunc, xwhere)            \
 		((*((auth)->ah_ops->ah_wrap))(auth, xdrs, \
@@ -373,7 +400,7 @@ __END_DECLS
 __BEGIN_DECLS
 struct svc_req;
 struct rpc_msg;
-enum auth_stat _svcauth_null (struct svc_req *, struct rpc_msg *);
+enum auth_stat _svcauth_none (struct svc_req *, struct rpc_msg *);
 enum auth_stat _svcauth_short (struct svc_req *, struct rpc_msg *);
 enum auth_stat _svcauth_unix (struct svc_req *, struct rpc_msg *);
 __END_DECLS
diff --git a/tirpc/rpc/auth_des.h b/tirpc/rpc/auth_des.h
index f3f9f31..39b5332 100644
--- a/tirpc/rpc/auth_des.h
+++ b/tirpc/rpc/auth_des.h
@@ -84,7 +84,7 @@ struct authdes_verf {
 		struct timeval adv_ctime;	/* clear time */
 	  	des_block adv_xtime;		/* crypt time */
 	} adv_time_u;
-  //u_long adv_int_u;
+  /*u_long adv_int_u;*/
   u_int32_t adv_int_u;
 };
 
diff --git a/tirpc/rpc/clnt.h b/tirpc/rpc/clnt.h
index 0b26189..9ee619e 100644
--- a/tirpc/rpc/clnt.h
+++ b/tirpc/rpc/clnt.h
@@ -1,7 +1,7 @@
 /*	$NetBSD: clnt.h,v 1.14 2000/06/02 22:57:55 fvdl Exp $	*/
 
 /*
- * Copyright (c) 2009, Sun Microsystems, Inc.
+ * Copyright (c) 2010, Oracle America, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -11,7 +11,7 @@
  * - Redistributions in binary form must reproduce the above copyright notice,
  *   this list of conditions and the following disclaimer in the documentation
  *   and/or other materials provided with the distribution.
- * - Neither the name of Sun Microsystems, Inc. nor the names of its
+ * - Neither the name of the "Oracle America, Inc." nor the names of its
  *   contributors may be used to endorse or promote products derived
  *   from this software without specific prior written permission.
  *
@@ -34,16 +34,12 @@
 
 /*
  * clnt.h - Client side remote procedure call interface.
- *
- * Copyright (c) 1986-1991,1994-1999 by Sun Microsystems, Inc.
- * All rights reserved.
  */
 
 #ifndef _TIRPC_CLNT_H_
 #define _TIRPC_CLNT_H_
 
-//#include <rpc/clnt_stat.h>
-#include "clnt_stat.h"
+#include <rpc/clnt_stat.h>
 #include <rpc/auth.h>
 
 #include <sys/cdefs.h>
diff --git a/tirpc/rpc/des.h b/tirpc/rpc/des.h
index e3d6897..d2881ad 100644
--- a/tirpc/rpc/des.h
+++ b/tirpc/rpc/des.h
@@ -33,6 +33,9 @@
  * Copyright (c) 1986 by Sun Microsystems, Inc.
  */
 
+#ifndef _RPC_DES_H_
+#define _RPC_DES_H_
+
 #define DES_MAXLEN 	65536	/* maximum # of bytes to encrypt  */
 #define DES_QUICKLEN	16	/* maximum # of bytes to encrypt quickly */
 
@@ -80,3 +83,5 @@ struct desparams {
  * Software DES.
  */
 extern int _des_crypt( char *, int, struct desparams * );
+
+#endif
diff --git a/tirpc/rpc/rpc.h b/tirpc/rpc/rpc.h
index 29e29e9..6c0222e 100644
--- a/tirpc/rpc/rpc.h
+++ b/tirpc/rpc/rpc.h
@@ -101,6 +101,7 @@ __END_DECLS
  */
 __BEGIN_DECLS
 int __rpc_nconf2fd(const struct netconfig *);
+int __rpc_nconf2fd_flags(const struct netconfig *, int);
 int __rpc_nconf2sockinfo(const struct netconfig *, struct __rpc_sockinfo *);
 int __rpc_fd2sockinfo(int, struct __rpc_sockinfo *);
 u_int __rpc_get_t_size(int, int, int);
diff --git a/tirpc/rpc/rpcent.h b/tirpc/rpc/rpcent.h
index 1d83550..7fd93d9 100644
--- a/tirpc/rpc/rpcent.h
+++ b/tirpc/rpc/rpcent.h
@@ -44,23 +44,27 @@
 /*	#pragma ident "@(#)rpcent.h   1.13    94/04/25 SMI"	*/
 /*      @(#)rpcent.h 1.1 88/12/06 SMI   */
 
+__BEGIN_DECLS
 
-//struct rpcent {
-//      char    *r_name;        /* name of server for this rpc program */
-//      char    **r_aliases;    /* alias list */
-//      int     r_number;       /* rpc program number */
-//};
+/* These are defined in /usr/include/rpc/netdb.h */
+#if 0
+struct rpcent {
+	char	*r_name;	/* name of server for this rpc program */
+	char	**r_aliases;	/* alias list */
+	int	r_number;	/* rpc program number */
+};
 
-__BEGIN_DECLS
-//extern struct rpcent *getrpcbyname_r(const char *, struct rpcent *,
-//				     char *, int);
-//extern struct rpcent *getrpcbynumber_r(int, struct rpcent *, char *, int);
-//extern struct rpcent *getrpcent_r(struct rpcent *, char *, int);
+extern struct rpcent *getrpcbyname_r(const char *, struct rpcent *,
+					char *, int);
+extern struct rpcent *getrpcbynumber_r(int, struct rpcent *, char *, int);
+extern struct rpcent *getrpcent_r(struct rpcent *, char *, int);
 
 /* Old interfaces that return a pointer to a static area;  MT-unsafe */
-//extern struct rpcent *getrpcbyname(char *);
-//extern struct rpcent *getrpcbynumber(int);
-//extern struct rpcent *getrpcent(void);
+extern struct rpcent *getrpcbyname(char *);
+extern struct rpcent *getrpcbynumber(int);
+extern struct rpcent *getrpcent(void);
+#endif
+
 extern void setrpcent(int) __THROW;
 extern void endrpcent(void) __THROW;
 __END_DECLS
diff --git a/tirpc/rpc/svc_auth.h b/tirpc/rpc/svc_auth.h
index 659e90c..14269d1 100644
--- a/tirpc/rpc/svc_auth.h
+++ b/tirpc/rpc/svc_auth.h
@@ -44,17 +44,23 @@
 /*
  * Interface to server-side authentication flavors.
  */
-typedef struct {
+typedef struct SVCAUTH {
 	struct svc_auth_ops {
-		int   (*svc_ah_wrap)(void);
-		int   (*svc_ah_unwrap)(void);
-		int   (*svc_ah_destroy)(void);
+		int     (*svc_ah_wrap)(struct SVCAUTH *, XDR *, xdrproc_t,
+				       caddr_t);
+		int     (*svc_ah_unwrap)(struct SVCAUTH *, XDR *, xdrproc_t,
+					 caddr_t);
+		int     (*svc_ah_destroy)(struct SVCAUTH *);
 		} *svc_ah_ops;
 	caddr_t svc_ah_private;
 } SVCAUTH;
 
-#define SVCAUTH_DESTROY(cred)		((*(cred)->svc_ah_ops->svc_ah_destroy)())
-#define svcauth_destroy(cred)		((*(cred)->svc_ah_ops->svc_ah_destroy)())
+#define SVCAUTH_WRAP(auth, xdrs, xfunc, xwhere) \
+	((*((auth)->svc_ah_ops->svc_ah_wrap))(auth, xdrs, xfunc, xwhere))
+#define SVCAUTH_UNWRAP(auth, xdrs, xfunc, xwhere) \
+	((*((auth)->svc_ah_ops->svc_ah_unwrap))(auth, xdrs, xfunc, xwhere))
+#define SVCAUTH_DESTROY(auth) \
+	((*((auth)->svc_ah_ops->svc_ah_destroy))(auth))
 
 /*
  * Server side authenticator
diff --git a/tirpc/rpc/svc_dg.h b/tirpc/rpc/svc_dg.h
index aef8e8b..332128d 100644
--- a/tirpc/rpc/svc_dg.h
+++ b/tirpc/rpc/svc_dg.h
@@ -45,6 +45,9 @@ struct svc_dg_data {
 	XDR		su_xdrs;			/* XDR handle */
 	char		su_verfbody[MAX_AUTH_BYTES];	/* verifier body */
 	void		*su_cache;		/* cached data, NULL if none */
+
+	struct msghdr	su_msghdr;		/* msghdr received from clnt */
+	unsigned char	su_cmsg[64];		/* cmsghdr received from clnt */
 };
 
 #define __rpcb_get_dg_xidp(x)	(&((struct svc_dg_data *)(x)->xp_p2)->su_xid)
diff --git a/tirpc/rpc/types.h b/tirpc/rpc/types.h
index d99a57b..52c30a2 100644
--- a/tirpc/rpc/types.h
+++ b/tirpc/rpc/types.h
@@ -39,7 +39,6 @@
 #define _TIRPC_TYPES_H
 
 #include <sys/types.h>
-//#include <sys/_null.h>
 
 typedef int32_t bool_t;
 typedef int32_t enum_t;
diff --git a/tirpc/rpc/xdr.h b/tirpc/rpc/xdr.h
index 3a6bc96..2c2a860 100644
--- a/tirpc/rpc/xdr.h
+++ b/tirpc/rpc/xdr.h
@@ -43,7 +43,7 @@
 #include <sys/cdefs.h>
 #include <stdio.h>
 #include <netinet/in.h>
-// Rajout pour la dfinition des types
+
 #include <rpc/types.h>
 
 /*
diff --git a/tirpc/spinlock.h b/tirpc/spinlock.h
index 8e9adb1..393fb83 100644
--- a/tirpc/spinlock.h
+++ b/tirpc/spinlock.h
@@ -37,37 +37,5 @@
 
 #ifndef _SPINLOCK_H_
 #define _SPINLOCK_H_
-#include <sys/cdefs.h>
-#include <sys/types.h>
-
-/*
- * Lock structure with room for debugging information.
- */
-struct _spinlock {
-	volatile long	access_lock;
-	volatile long	lock_owner;
-	volatile char	*fname;
-	volatile int	lineno;
-};
-typedef struct _spinlock spinlock_t;
-
-#define	_SPINLOCK_INITIALIZER	{ 0, 0, 0, 0 }
-
-#define _SPINUNLOCK(_lck)	_spinunlock(_lck);
-#ifdef	_LOCK_DEBUG
-#define	_SPINLOCK(_lck)		_spinlock_debug(_lck, __FILE__, __LINE__)
-#else
-#define	_SPINLOCK(_lck)		_spinlock(_lck)
-#endif
-
-/*
- * Thread function prototype definitions:
- */
-__BEGIN_DECLS
-long	_atomic_lock(volatile long *);
-void	_spinlock(spinlock_t *);
-void	_spinunlock(spinlock_t *);
-void	_spinlock_debug(spinlock_t *, char *, int);
-__END_DECLS
 
 #endif /* _SPINLOCK_H_ */
